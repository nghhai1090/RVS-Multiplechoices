
public class SecondKap extends Kapitel {
    public SecondKap(boolean s) {
    	super(s);
    	Inhalt i= new Inhalt("was ist Socket","Socket","T");
    	i.addAnswer("Tür zum Netzwerk kommunikation durch Abgabe / Abholung von Nachrichten an der Tür");
    	i.addAnswer("Kommunikationschnittstelle zwischen Anwendungschicht und Transportschicht");
    	i.addWrong("zum Betreiben von Programmen");
    	addInhalt(i);
    	Inhalt i1= new Inhalt("Anforderungen der Anwendung an Transportdienst","Anforderungen an Transportdienst","T");
    	i1.addAnswer("Zuverlässigkeit beim Datentransfer");
    	i1.addAnswer("Zeitverhalten");
    	i1.addAnswer("Bandbreite");
    	i1.addAnswer("Sicherheit");
    	addInhalt(i1);
    	Inhalt i2= new Inhalt("Anwendungsprotokoll und benutzter Transport von Email","Anwendungsprotokoll und benutzter Transport von Email","T");
    	i2.addAnswer("SMTP[RFC 2821]");
    	i2.addAnswer("TCP");
    	i2.addWrong("Telnet[RFC 854]");
    	i2.addWrong("HTTP/1.1 : RFC 2616");
    	i2.addWrong("FTP[RFC 959]");
    	i2.addWrong("HTTP oder RTP[RFC 1889]");
    	i2.addWrong("SIP, RTP, proprietär");
    	i2.addWrong("UDP");
    	addInhalt(i2);
    	Inhalt i3= new Inhalt("Anwendungsprotokoll und benutzter Transport von remote terminal access","Anwendungsprotokoll und benutzter Transport von von remote terminal access","T");
    	i3.addWrong("SMTP[RFC 2821]");
    	i3.addAnswer("TCP");
    	i3.addAnswer("Telnet[RFC 854]");
    	i3.addWrong("HTTP/1.1 : RFC 2616");
    	i3.addWrong("FTP[RFC 959]");
    	i3.addWrong("HTTP oder RTP[RFC 1889]");
    	i3.addWrong("SIP, RTP, proprietär");
    	i3.addWrong("UDP");
    	addInhalt(i3);
    	Inhalt i4= new Inhalt("Anwendungsprotokoll und benutzter Transport von WWW","Anwendungsprotokoll und benutzter Transport von WWW","T");
    	i4.addWrong("SMTP[RFC 2821]");
    	i4.addAnswer("TCP");
    	i4.addWrong("Telnet[RFC 854]");
    	i4.addAnswer("HTTP/1.0 : RFC 1945");
    	i4.addAnswer("HTTP/1.1 : RFC 2616");
    	i4.addAnswer("HTTP/2.0 : RFC 7540");
    	i4.addAnswer("HTTP/3.0 in Entwicklung");
    	i4.addWrong("FTP[RFC 959]");
    	i4.addWrong("HTTP oder RTP[RFC 1889]");
    	i4.addWrong("SIP, RTP, proprietär");
    	i4.addWrong("UDP");
    	addInhalt(i4);
    	Inhalt i5= new Inhalt("Anwendungsprotokoll und benutzter Transport von Dateitransfer","Anwendungsprotokoll und benutzter Transport von Dateitransfer","T");
    	i5.addWrong("SMTP[RFC 2821]");
    	i5.addAnswer("TCP");
    	i5.addWrong("Telnet[RFC 854]");
    	i5.addWrong("HTTP/1.1 : RFC 2616");
    	i5.addAnswer("FTP[RFC 959]");
    	i5.addWrong("HTTP oder RTP[RFC 1889]");
    	i5.addWrong("SIP, RTP, proprietär");
    	i5.addWrong("UDP");
    	addInhalt(i5);
    	Inhalt i6= new Inhalt("Anwendungsprotokoll und benutzter Transport von Streaming multimedia","Anwendungsprotokoll und benutzter Transport von Streaming multimedia","T");
    	i6.addWrong("SMTP[RFC 2821]");
    	i6.addAnswer("TCP");
    	i6.addWrong("Telnet[RFC 854]");
    	i6.addWrong("HTTP/1.1 : RFC 2616");
    	i6.addWrong("FTP[RFC 959]");
    	i6.addAnswer("HTTP oder RTP[RFC 1889]");
    	i6.addWrong("SIP, RTP, proprietär");
    	i6.addAnswer("UDP");
    	addInhalt(i6);
    	Inhalt i7= new Inhalt("Anwendungsprotokoll und benutzter Transport von Internettelefonie","Anwendungsprotokoll und benutzter Transport von Internettelefonie","T");
    	i7.addWrong("SMTP[RFC 2821]");
    	i7.addWrong("TCP");
    	i7.addWrong("Telnet[RFC 854]");
    	i7.addWrong("HTTP/1.1 : RFC 2616");
    	i7.addWrong("FTP[RFC 959]");
    	i7.addWrong("HTTP oder RTP[RFC 1889]");
    	i7.addAnswer("SIP, RTP, proprietär");
    	i7.addAnswer("UDP");
    	addInhalt(i7);
    	Inhalt i8= new Inhalt("HTTP","HTTP","T");
    	i8.addAnswer("HTTP/1.0 : RFC 1945");
    	i8.addAnswer("HTTP/1.1 : RFC 2616");
    	i8.addAnswer("HTTP/2.0 : RFC 7540");
    	i8.addAnswer("HTTP/3.0 in Entwicklung");
    	i8.addAnswer("TCP");
    	i8.addAnswer("Port 80");
    	i8.addWrong("Port 25");
    	i8.addWrong("Port 110");
    	i8.addWrong("Port 194");
    	i8.addAnswer("zustandlos: Server speichert keine Informationen über vorangegangene Verbindungen");
    	i8.addWrong("HTTP/1.0 : RFC 1005");
    	i8.addWrong("HTTP/1.1 : RFC 2000");
    	i8.addWrong("HTTP/2.0 : RFC 2345");
    	i8.addWrong("UDP");
    	i8.addAnswer("Anwendungsprotokoll des Webs");
    	addInhalt(i8);
    	Inhalt i9= new Inhalt("Nonpersistent-HTTP","Nonpersistent-HTTP","T");
    	i9.addAnswer("maximal ein Objekt pro Verbindung");
    	i9.addAnswer("wird von HTTP/1.0 : RFC 1945 benutzt");
    	i9.addWrong("mehrere Objekte pro Verbindung");
    	i9.addWrong("ohne Pipelining : Client fordert erst neues Objekt an, nachdem das vorangehende ampfangen wurde");
        i9.addWrong("mit Pipelining : Client fordert neues Objekt an, sobald er auf eine Referenz stößt");
    	addInhalt(i9);
    	Inhalt i10= new Inhalt("Persistent HTTP","Persistent HTTP","T");
    	i10.addWrong("maximal ein Objekt pro Verbindung");
    	i10.addWrong("wird von HTTP/1.0 : RFC 1945 benutzt");
    	i10.addAnswer("mehrere Objekte pro Verbindung");
    	i10.addAnswer("ohne Pipelining : Client fordert erst neues Objekt an, nachdem das vorangehende ampfangen wurde");
        i10.addAnswer("mit Pipelining : Client fordert neues Objekt an, sobald er auf eine Referenz stößt");
    	i10.addWrong("ohne Pipelining :  Client fordert neues Objekt an, sobald er auf eine Referenz stößt");
    	i10.addWrong("mit Pipelining : Client fordert erst neues Objekt an, nachdem das vorangehende ampfangen wurde");
    	addInhalt(i10);
    	Inhalt i32 = new Inhalt("HTTP/1.0","HTTP/1.0","T");
    	i32.addAnswer("RFC 1945");
    	i32.addWrong("Benutzt Persistent HTTP mit Pipelining im Defaut-Modus");
    	i32.addWrong("Benutzt Persistent HTTP mit Pipelining ");
    	i32.addWrong("Benutzt Non-Persistent HTTP mit Pipelining im Defaut-Modus");
    	i32.addWrong("Benutzt Persistent HTTP ohne Pipelining ");
    	i32.addAnswer("Benutzt Non-Persistent HTTP ");
    	i32.addWrong("keine Client Informationen transferiert");
    	i32.addWrong("RFC 2616");
    	addInhalt(i32);
    	Inhalt i11= new Inhalt("HTTP/1.1 und Persistent/Non Persistent HTTP, Pipelining ","HTTP/1.1","T");
    	i11.addAnswer("Benutzt Persistent HTTP mit Pipelining im Defaut-Modus");
    	i11.addWrong("Benutzt Persistent HTTP mit Pipelining ");
    	i11.addWrong("Benutzt Non-Persistent HTTP mit Pipelining im Defaut-Modus");
    	i11.addWrong("Benutzt Persistent HTTP ohne Pipelining ");
    	i11.addWrong("Benutzt Non-Persistent HTTP ");
    	i11.addAnswer("RFC 2616");
    	i11.addWrong("RFC 1945");
    	addInhalt(i11);
    	Inhalt i12= new Inhalt("Vorteile von Cookies","Vorteile Cookies","T");
    	i12.addAnswer("Autorisierung");
    	i12.addAnswer("speichert Zustand einer Benutzersitzung");
    	addInhalt(i12);
    	Inhalt i13= new Inhalt("Nachteile von Cookies","Nachteile Cookies","T");
    	i13.addAnswer("Übermitteln Informationen");
    	i13.addAnswer("Suchmachinen nutzen Cookies um Nutzer zu erlernen");
    	i13.addAnswer("Weitergabe an Dritte");
    	addInhalt(i13);
    	Inhalt i14= new Inhalt("SMTP","SMTP","T");
        i14.addAnswer("RFC 2821");
        i14.addWrong("UDP");
        i14.addWrong("RFC 2009");
        i14.addWrong("User speichert Emails und greifen direkt auf Emails");
        i14.addWrong("User speichert Emails und greifen auf Emails durch POP und IMAP");
        i14.addAnswer("TCP");
        i14.addAnswer("HAndshake, Nachrichtentransfer, Verbindung beenden");
        i14.addWrong("Verbindungslos");
    	i14.addAnswer("7-bit ASCII Formatt zeilenweise organisiert");
    	i14.addAnswer("Mail Server speichert empfangene Emails");
    	i14.addAnswer("User greifen auf Emails zu, durch POP und IMAP");
    	i14.addWrong("Port 110");
    	i14.addWrong("UDP");
    	i14.addAnswer("Port 25");
    	i14.addWrong("Port 80");
    	i14.addWrong("Port 194");
    	addInhalt(i14);
    	Inhalt i15 = new Inhalt("POP3","POP3","T");
    	i15.addAnswer("RFC 1939");
    	i15.addAnswer("3 Phasen");
    	i15.addAnswer("Authentifizierung");
    	i15.addAnswer("Transaktion(inkl Löschen von Nachrichten)");
    	i15.addAnswer("Update");
    	i15.addWrong("Transaktion( nicht inkl Löschen von Nachrichten)");
        i15.addWrong("Verwalten von Ordnen aufm Server");
        i15.addWrong("Auslesen von Mail-Headern");
        i15.addWrong("Suchen von Nachrichten");
    	i15.addWrong("RFC 3501");
    	i15.addAnswer("Port 110");
    	i15.addAnswer("TCP");
    	i15.addWrong("UDP");
    	i15.addWrong("Port 25");
    	i15.addWrong("Port 80");
    	i15.addWrong("Port 194");
    	addInhalt(i15);
    	Inhalt i16 = new Inhalt("IMAP","IMAP","T");
    	i16.addWrong("RFC 1939");
    	i16.addWrong("3 Phasen");
    	i16.addAnswer("Authentifizierung");
    	i16.addAnswer("Transaktion(inkl Löschen von Nachrichten)");
    	i16.addWrong("Update");
    	i16.addWrong("Transaktion( nicht inkl Löschen von Nachrichten)");
        i16.addAnswer("Verwalten von Ordnen aufm Server");
        i16.addAnswer("Auslesen von Mail-Headern");
        i16.addAnswer("Suchen von Nachrichten");
    	i16.addAnswer("RFC 3501");
    	addInhalt(i16);
    	Inhalt i17 = new Inhalt("Response Status Code 200","Response Status Code 200","T");
    	i17.addAnswer("OK");
    	i17.addWrong("Moved Permanently");
    	i17.addWrong("Bad request");
    	i17.addWrong("Not Found");
    	i17.addWrong("HTTP Version not Supported");
    	addInhalt(i17);
    	Inhalt i18 = new Inhalt("Response Status Code 301","Response Status Code 301","T");
    	i18.addWrong("OK");
    	i18.addAnswer("Moved Permanently");
    	i18.addWrong("Bad request");
    	i18.addWrong("Not Found");
    	i18.addWrong("HTTP Version not Supported");
    	addInhalt(i18);
    	Inhalt i19 = new Inhalt("Response Status Code 400","Response Status Code 400","T");
    	i19.addWrong("OK");
    	i19.addWrong("Moved Permanently");
    	i19.addAnswer("Bad request");
    	i19.addWrong("Not Found");
    	i19.addWrong("HTTP Version not Supported");
    	addInhalt(i19);
    	Inhalt i20 = new Inhalt("Response Status Code 404","Response Status Code 404","T");
    	i20.addWrong("OK");
    	i20.addWrong("Moved Permanently");
    	i20.addWrong("Bad request");
    	i20.addAnswer("Not Found");
    	i20.addWrong("HTTP Version not Supported");
    	addInhalt(i20);
    	Inhalt i21 = new Inhalt("Response Status Code 505","Response Status Code 505","T");
    	i21.addWrong("OK");
    	i21.addWrong("Moved Permanently");
    	i21.addWrong("Bad request");
    	i21.addWrong("Not Found");
    	i21.addAnswer("HTTP Version not Supported");
    	addInhalt(i21);
    	Inhalt i22= new Inhalt("DNS","DNS","T");
    	i22.addAnswer("Domain Name System");
    	i22.addAnswer("Protokoll der Anwendungsschicht zur Übersetzung Name <-> IP Adresse");
    	i22.addAnswer("DNS Namen von recht nach links abgearbeitet");
    	i22.addAnswer("kein Zentrales DNS ");
    	i22.addWrong("es gibt ein zentrales DNS ");
    	i22.addWrong("jeder DNS Server hat alle Abbindungen von Namen auf IP Adressen");
    	i22.addAnswer("kein DNS Server hat alle Abbindungen von Namen auf IP Adressen");
    	i22.addWrong("Protokoll der Transportschicht zur Übersetzung Name <-> IP Adresse");
    	i22.addWrong("DNS Namen von links nach recht abgearbeitet");
    	i22.addWrong("Domain Name Server");
    	addInhalt(i22);
    	Inhalt i23= new Inhalt("Lokale Name Server","Lokale Name Server","T");
    	i23.addAnswer("Gehören zu einem ISP");
    	i23.addAnswer("jede Anfragen wird erst hier geleitet");
    	i23.addAnswer("leitet Anfrage zum Root Name Server, wenn eine/en Adresse/Namen nicht auflösbar");
    	i23.addWrong("werden von lokalen Name Server kontaktiert, wenn diese eine/en Adresse/Namen nicht auflösen können");
    	i23.addWrong("leitet Anfrage zum autorativen Name Server, wenn eine/en Adresse/Namen nicht auflösbar");
    	i23.addWrong("ein Netz aus replizierten Servern");
    	addInhalt(i23);
    	Inhalt i24 = new Inhalt("Root Name Server","Root Name Server","T");
    	i24.addWrong("Gehören zu einem ISP");
    	i24.addWrong("jede Anfragen wird erst hier geleitet");
    	i24.addWrong("leitet Anfrage zum Root Name Server, wenn eine/en Adresse/Namen nicht auflösbar");
    	i24.addAnswer("werden von lokalen Name Server kontaktiert, wenn diese eine/en Adresse/Namen nicht auflösen können");
    	i24.addAnswer("leitet Anfrage zum autorativen Name Server, wenn eine/en Adresse/Namen nicht auflösbar");
    	i24.addAnswer("aktuel 13 Root Server, meisten in Nord Amerika");
    	i24.addAnswer("ein Netz aus replizierten Servern");
    	addInhalt(i24);
    	Inhalt i25= new Inhalt("Rekursive Anfrage","Rekursive Anfrage","T");
    	i25.addAnswer("kann zum hohen Last führen");
    	i25.addWrong("host -> lokaler Name Server -> root name Server-> lokaler name server->autorativer Name Server-> lokaler name server -> host");
    	i25.addAnswer("host -> lokaler Name Server -> Root Name Server -> Autorativer Name Server -> Root Name Server -> lokaler Name Server -> Host");
    	addInhalt(i25);
    	Inhalt i26= new Inhalt("Iterative Anfrage","Iterative Anfrage","T");
    	i26.addWrong("kann zum hohen Last führen");
    	i26.addAnswer("host -> lokaler Name Server -> root name Server-> lokaler name server->autorativer Name Server-> lokaler name server -> host");
    	i26.addWrong("host -> lokaler Name Server -> Root Name Server -> Autorativer Name Server -> Root Name Server -> lokaler Name Server -> Host");
    	addInhalt(i26);
    	Inhalt i27= new Inhalt("CDN","CDN","T");
    	i27.addAnswer("um Transfer zu sparen, werden Inhalte in Kopien auf vielen Servern gespeichert");
    	i27.addAnswer("Content Distribution Network");
    	i27.addWrong("Content Domain Network");
    	i27.addAnswer("Netz regional verteilter und über das Internet verbundender Server");
    	i27.addAnswer("ermöglich auswahl und verteilung der inhalte ");
    	i27.addAnswer("Server durch Updates aktualisieren");
    	i27.addAnswer("Gemeinsame Teilwege beim Ausliefern derselben Inhalte an verschiedene Kunden");
    	addInhalt(i27);
    	Inhalt i28= new Inhalt("DASH","DASH","T");
        i28.addAnswer("Server unterteilt video datei in mehreren Chunks, Chunks werden in verschiedenen Formaten (Kodierungen) vorgehalten");
        i28.addAnswer("Server stellt Chunks und manifestdatei dem Client zur Verfügung");
        i28.addAnswer("manifest Datei enthalt URLs für die Chunks");
        i28.addAnswer("Client misst Bandbreite zwischen Server und Client periodisch");
        i28.addAnswer("Client holt Manifestdatei, Fordert Chunks nacheinander in bestimmter Qualität an ");
        i28.addAnswer("Auswahl der maximalen mit gegebener Bandbreite möglichen Kodierungsrate");
        i28.addAnswer("Kodierung kann während der Übertragung wechseln");
        i28.addAnswer("Client bestimmt wann, in welcher Form und von woher ein chunk angefordert wird");
        i28.addAnswer("Dynamic Adaptive Streaming over HTTP");
        i28.addWrong("Dynamic Active Streaming over HTTP");
        i28.addWrong("Dynamic Action Streaming over HTTP");
        i28.addWrong("Kodierung kann während der Übertragung nicht wechseln");
        i28.addWrong("Server bestimmt wann, in welcher Form und von woher ein chunk angefordert wird");
        i28.addWrong("Auswahl der maximalen mit gegebener Kodierungsrate möglichen Bandbreite");
        addInhalt(i28);
        Inhalt i29= new Inhalt("Socket bei Clientseite","Socket Client","T");
        i29.addAnswer("SAP Service Access Point");
        i29.addWrong("CEP Connection Endpoint");
        addInhalt(i29);
        Inhalt i30= new Inhalt("Socket bei Serverseite","Socket Server","T");
        i30.addAnswer("SAP Service Access Point");
        i30.addAnswer("CEP Connection Endpoint");
        addInhalt(i30);
        Inhalt i31= new Inhalt("Authentifizierung und Autorisierung","Authentifizierung und Autorisierung","T");
        i31.addAnswer("Authentifizierung : Überprüfung der Identität");
        i31.addAnswer(" Autorisierung : Prüfung der Zugangsrechte, nutzt Authentifisierung");
        i31.addWrong(" Autorisierung: Überprüfung der Identität");
        i31.addWrong(" Authentifizierung : Prüfung der Zugangsrechte, nutzt Autorisierung");
        addInhalt(i31);
        Inhalt i33= new Inhalt("Wie reagiert HTTP/1.1 und 1.0 auf Response Status Code 301","HTTP und 301","T");
        i33.addAnswer("HTTP 1.1 enthält die Weiterleitung direkt in Location Header und ruf die neue Adresse selbständig an, HTTP 1.0 reagiert genauso");
        i33.addWrong("HTTP 1.1 enthält die Weiterleitung direkt in Location Header und ruf die neue Adresse selbständig an, bei HTTP 1.0 wird keine neue Adresse angerufen ");
        i33.addWrong("HTTP 1.0 enthält die Weiterleitung direkt in Location Header und ruf die neue Adresse selbständig an, bei HTTP 1.1 wird keine neue Adresse angerufen");
        i33.addWrong("die beiden rufen keine neue Adresse an und geben Fehler aus in Browser");
        addInhalt(i33);
        Inhalt i34 = new Inhalt(" jitter ausgleich bei client ","jitter ausgleich bei client","T");
        i34.addAnswer("Client seitige Pufferung");
        i34.addWrong("Server seitige Pufferung");
        addInhalt(i34);
        Inhalt i35= new Inhalt("Autoritative DNS Server","Autoritative DNS Server","T");
        i35.addAnswer("haltet DNS-Datensaetze von öffentlich zugänglichen Host im Internet der Organisation (wie Webservern und Mailservern ) öffentlich zugänglich bereits ");
        addInhalt(i35);
        Inhalt i36= new Inhalt("Top Level Domain Server","Top Level Domain Server","T");
        i36.addAnswer("verantwortlich für Top Level Domains (de, com, org)");
        i36.addWrong("zentraler DNS");
        addInhalt(i36);
        Inhalt i37= new Inhalt("Name Server Hierarchie","Name Server Hierarchie","T");
        i37.addAnswer("Root Server");
        i37.addAnswer("Top Level Domain Server");
        i37.addAnswer("Autoritative DNS Server");
        i37.addAnswer("lokale DNS Server");
        addInhalt(i37);
        Inhalt i38 = new Inhalt("was ist Chunk","Chunk","T");
        i38.addAnswer("Dauer 2s bis 10s");
        i38.addWrong("Dauer 0.5 bis 1s");
        i38.addWrong("Dauer 1s bis 2s");
        i38.addAnswer("Videoabschnitt , der in mehreren unterschiedlichen Raten/Qualitaet kodiert werden kann und in unterschiedlichen Dateien gespeichert ist");
        i38.addAnswer("jede Chunk enthaelt die gleiche Anzahl von Videobildern (letzter Chunk kann weniger Einzelbilder enthälten)");
        i38.addWrong("Videoabschnitt , der in mehreren unterschiedlichen Raten/Qualitaet kodiert werden kann und in einer Datei gespeichert ist");
        i38.addWrong("jede Chunk enthaelt die gleiche Anzahl von Videobildern ");
        i38.addWrong("Videoabschnitt , der in einer bestimmten Rate/Qualitaet kodiert werden kann und in einer Datei gespeichert ist");
        i38.addWrong("Videoabschnitt , der in einer bestimmten Rate/Qualitaet kodiert werden kann und in unterschiedlichen Dateien gespeichert ist");
        addInhalt(i38);
        Inhalt i40= new Inhalt("Manifestdatei","Manifestdatei","T");
        i40.addAnswer("enthält Speicherort und Kodierungsrate der Chunks");
        i40.addWrong("enthält Chunks");
        addInhalt(i40);
        Inhalt i39= new Inhalt("CDN Anbieter","CND Anbieter","T");
        i39.addAnswer("Akamai Technologies");
        i39.addAnswer("Azure CDN");
        i39.addAnswer("Amazon CloudFront");
        i39.addAnswer("Cloudflare");
        i39.addAnswer("Goole Cloud CDN");
        i39.addAnswer("Limelight Network");
        addInhalt(i39);
        Inhalt i41= new Inhalt("Faktoren bei der Auswahl der Replica Server wenn Client eine Anfrage an das CDN stellt","Faktoren bei der Auswahl der Replica Server","T");
        i41.addAnswer("geografische Faktoren");
        i41.addAnswer("netzwerkbezogene Faktoren (Bandbreite, Performance)");
        i41.addAnswer("Lastausgleicht");
        i41.addAnswer("tageszeitliche Effekte");
        i41.addAnswer("begrenzter Verfügbarkeit von selten abgerufenen Dateien");
        i41.addAnswer("Übertragungskosten");
        i41.addWrong("Beliebtheit (wahlt der beliebste Server)");
        i41.addWrong("Beliebtheit (wahlt der wenigst beliebte Server)");
        addInhalt(i41);
        addAnswer("COW");
        addAnswer("BULL");
        addAnswer("DOG");
        addAnswer("TIGER");
        addAnswer("CAT");
        addAnswer("MOUSE");
        addAnswer("BUGS");
        addAnswer("WRONG ANSWER");
        addAnswer("THIS ONE IS WRONG ANSWER");
        addAnswer("RIGHT ANSWER");
        addAnswer("RIGHT ANSWER HERE");
        addAnswer("Cmon");
        addAnswer("R YOU FEELING LUCKY ?");
        setFrage();
    }
}
